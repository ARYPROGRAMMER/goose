# This is a **reuseable** workflow that bundles the Desktop App for macOS.
# It doesn't get triggered on its own. It gets used in multiple workflows:
#  - release.yml
#  - canary.yml
on:
  workflow_call:
    inputs:
      version:
        required: false
        default: ""
        type: string
      # Let's allow overriding the OSes and architectures in JSON array form:
      # e.g. '["ubuntu-latest","macos-latest"]'
      # If no input is provided, these defaults apply.
      operating-systems:
        type: string
        required: false
        default: '["ubuntu-latest","macos-latest"]'
      architectures:
        type: string
        required: false
        default: '["x86_64","aarch64"]'
      ref:
        type: string
        required: false
        default: 'refs/heads/main'

name: "Reusable workflow to build CLI"

env:
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0  # Disable incremental compilation to save space
  RUST_BACKTRACE: 1

jobs:
  build-cli:
    name: Build CLI
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: ${{ fromJson(inputs.operating-systems) }}
        architecture: ${{ fromJson(inputs.architectures) }}
        include:
          - os: ubuntu-latest
            target-suffix: unknown-linux-gnu
          - os: macos-latest
            target-suffix: apple-darwin

    steps:
      - name: Check initial disk space
        run: df -h

      # Platform-specific disk cleanup
      - name: Free up disk space (Ubuntu)
        if: matrix.os == 'ubuntu-latest'
        run: |
          echo "=== Ubuntu Disk Cleanup ==="
          # Remove large pre-installed software
          sudo rm -rf \
            /opt/google/chrome \
            /opt/microsoft/msedge \
            /opt/microsoft/powershell \
            /usr/lib/mono \
            /usr/local/lib/android \
            /usr/local/lib/node_modules \
            /usr/local/share/chromium \
            /usr/local/share/powershell \
            /usr/share/dotnet \
            /usr/share/swift \
            /opt/az \
            /opt/hostedtoolcache/CodeQL \
            /opt/hostedtoolcache/Java_Temurin-Hotspot \
            /opt/hostedtoolcache/Ruby \
            /opt/hostedtoolcache/go \
            /opt/hostedtoolcache/node \
            /usr/local/graalvm \
            /usr/local/.ghcup \
            /usr/local/share/boost \
            /usr/local/share/vcpkg \
            /usr/local/lib/heroku
          
          # Clean package managers
          sudo apt-get clean
          sudo apt-get autoremove -y
          docker system prune -af 2>/dev/null || true
          npm cache clean --force 2>/dev/null || true
          df -h

      - name: Free up disk space (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          echo "=== macOS Disk Cleanup ==="
          # Clean npm cache
          npm cache clean --force 2>/dev/null || true
          # Clean Homebrew cache
          brew cleanup 2>/dev/null || true
          # Remove unnecessary large directories
          rm -rf ~/Library/Caches/* 2>/dev/null || true
          # Clean docker if present
          docker system prune -af 2>/dev/null || true
          # Remove old Xcode simulators
          xcrun simctl delete unavailable 2>/dev/null || true
          df -h

      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # pin@v4
        with:
          ref: ${{ inputs.ref }}
          fetch-depth: 0

      - name: Update version in Cargo.toml
        if: ${{ inputs.version != '' }}
        run: |
          sed -i.bak 's/^version = ".*"/version = "'${{ inputs.version }}'"/' Cargo.toml
          rm -f Cargo.toml.bak

      # Install and configure sccache with fallback options
      - name: Install sccache (Ubuntu)
        if: matrix.os == 'ubuntu-latest'
        run: |
          SCCACHE_VERSION=v0.8.2
          curl -L "https://github.com/mozilla/sccache/releases/download/${SCCACHE_VERSION}/sccache-${SCCACHE_VERSION}-x86_64-unknown-linux-musl.tar.gz" | tar xz
          sudo mv sccache-*/sccache /usr/local/bin/
          echo "RUSTC_WRAPPER=sccache" >> $GITHUB_ENV
          echo "SCCACHE_GHA_ENABLED=true" >> $GITHUB_ENV
          # Fallback to local cache if GHA cache fails
          echo "SCCACHE_GHA_CACHE_TO=gha" >> $GITHUB_ENV
          echo "SCCACHE_GHA_CACHE_FROM=gha" >> $GITHUB_ENV

      - name: Install sccache (macOS)
        if: matrix.os == 'macos-latest'
        run: |
          SCCACHE_VERSION=v0.8.2
          curl -L "https://github.com/mozilla/sccache/releases/download/${SCCACHE_VERSION}/sccache-${SCCACHE_VERSION}-x86_64-apple-darwin.tar.gz" | tar xz
          sudo mv sccache-*/sccache /usr/local/bin/
          echo "RUSTC_WRAPPER=sccache" >> $GITHUB_ENV
          echo "SCCACHE_GHA_ENABLED=true" >> $GITHUB_ENV
          # Fallback to local cache if GHA cache fails
          echo "SCCACHE_GHA_CACHE_TO=gha" >> $GITHUB_ENV
          echo "SCCACHE_GHA_CACHE_FROM=gha" >> $GITHUB_ENV

      # Use updated sccache action with better error handling
      - name: Run sccache-cache
        uses: mozilla-actions/sccache-action@676c0e67b665684f17941acf5cc3af83bcf10228 # pin@v0.0.6
        continue-on-error: true  # Don't fail build if cache setup fails

      # Fallback: Set up local sccache if GHA cache fails
      - name: Setup fallback sccache
        if: failure()
        run: |
          echo "GitHub Actions cache failed, using local cache"
          mkdir -p ~/.cache/sccache
          echo "SCCACHE_DIR=~/.cache/sccache" >> $GITHUB_ENV
          echo "SCCACHE_GHA_ENABLED=false" >> $GITHUB_ENV

      # Optimized cargo caching
      - name: Cache Cargo and Target
        uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # pin@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-${{ matrix.architecture }}-cargo-target-${{ hashFiles('**/Cargo.lock') }}-v4
          restore-keys: |
            ${{ runner.os }}-${{ matrix.architecture }}-cargo-target-${{ hashFiles('**/Cargo.lock') }}-
            ${{ runner.os }}-${{ matrix.architecture }}-cargo-target-

      # Clean cargo cache if it's too large
      - name: Limit cache sizes
        run: |
          # Check and limit cargo cache size
          CARGO_CACHE_SIZE=$(du -sm ~/.cargo 2>/dev/null | cut -f1 || echo "0")
          echo "Cargo cache size: ${CARGO_CACHE_SIZE}MB"
          
          if [ "$CARGO_CACHE_SIZE" -gt 3000 ]; then
            echo "Cargo cache too large (${CARGO_CACHE_SIZE}MB), cleaning..."
            rm -rf ~/.cargo/registry/cache
            rm -rf ~/.cargo/git/db
            echo "Cleaned cargo cache"
          fi
          
          # Check target directory size
          if [ -d "target" ]; then
            TARGET_SIZE=$(du -sm target 2>/dev/null | cut -f1 || echo "0")
            echo "Target directory size: ${TARGET_SIZE}MB"
            
            if [ "$TARGET_SIZE" -gt 8000 ]; then
              echo "Target directory too large (${TARGET_SIZE}MB), cleaning..."
              rm -rf target/*/incremental
              find target -name "*.rmeta" -delete 2>/dev/null || true
              echo "Cleaned target directory"
            fi
          fi

      - name: Install cross
        run: source ./bin/activate-hermit && cargo install cross --git https://github.com/cross-rs/cross

      # Install Go for building temporal-service
      - name: Set up Go
        uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # pin@v5
        with:
          go-version: '1.21'

      - name: Check disk space before build
        run: df -h

      - name: Build CLI
        env:
          CROSS_NO_WARNINGS: 0
          RUST_LOG: debug
          RUST_BACKTRACE: 1
          CROSS_VERBOSE: 1
        run: |
          source ./bin/activate-hermit
          export TARGET="${{ matrix.architecture }}-${{ matrix.target-suffix }}"
          rustup target add "${TARGET}"
          echo "Building for target: ${TARGET}"
          echo "Rust toolchain info:"
          rustup show
          echo "Cross version:"
          cross --version

          echo "Building with explicit PROTOC path..."
          cross build --release --target ${TARGET} -p goose-cli -vv

      - name: Clean intermediate artifacts after build
        run: |
          echo "Cleaning intermediate build artifacts..."
          # Remove .rmeta files (metadata only, not needed)
          find target -name "*.rmeta" -delete 2>/dev/null || true
          # Remove fingerprint files
          find target -name ".fingerprint" -type d -exec rm -rf {} + 2>/dev/null || true
          df -h

      - name: Build temporal-service for target platform
        run: |
          source ./bin/activate-hermit
          export TARGET="${{ matrix.architecture }}-${{ matrix.target-suffix }}"
          
          # Set Go cross-compilation variables based on target
          case "${TARGET}" in
            "x86_64-unknown-linux-gnu")
              export GOOS=linux
              export GOARCH=amd64
              BINARY_NAME="temporal-service"
              ;;
            "aarch64-unknown-linux-gnu")
              export GOOS=linux
              export GOARCH=arm64
              BINARY_NAME="temporal-service"
              ;;
            "x86_64-apple-darwin")
              export GOOS=darwin
              export GOARCH=amd64
              BINARY_NAME="temporal-service"
              ;;
            "aarch64-apple-darwin")
              export GOOS=darwin
              export GOARCH=arm64
              BINARY_NAME="temporal-service"
              ;;
            *)
              echo "Unsupported target: ${TARGET}"
              exit 1
              ;;
          esac
          
          echo "Building temporal-service for ${GOOS}/${GOARCH}..."
          cd temporal-service
          go build -o "../target/${TARGET}/release/${BINARY_NAME}" main.go
          echo "temporal-service built successfully for ${TARGET}"

      - name: Package CLI with temporal-service
        run: |
          source ./bin/activate-hermit
          export TARGET="${{ matrix.architecture }}-${{ matrix.target-suffix }}"
          
          # Create a directory for the package contents
          mkdir -p "target/${TARGET}/release/goose-package"
          
          # Copy binaries
          cp "target/${TARGET}/release/goose" "target/${TARGET}/release/goose-package/"
          cp "target/${TARGET}/release/temporal-service" "target/${TARGET}/release/goose-package/"
          
          # Create the tar archive with both binaries
          cd "target/${TARGET}/release"
          tar -cjf "goose-${TARGET}.tar.bz2" -C goose-package .
          echo "ARTIFACT=target/${TARGET}/release/goose-${TARGET}.tar.bz2" >> $GITHUB_ENV

      - name: Show sccache stats
        run: sccache --show-stats

      - name: Final cleanup
        run: |
          echo "Final cleanup to save space..."
          # Remove build artifacts that are no longer needed
          rm -rf target/*/debug 2>/dev/null || true
          rm -rf target/*/deps 2>/dev/null || true
          rm -rf target/*/build 2>/dev/null || true
          rm -rf target/*/incremental 2>/dev/null || true
          # Clean Go build cache
          go clean -cache 2>/dev/null || true
          df -h

      - name: Upload CLI artifact
        uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # pin@v4
        with:
          name: goose-${{ matrix.architecture }}-${{ matrix.target-suffix }}
          path: ${{ env.ARTIFACT }}
