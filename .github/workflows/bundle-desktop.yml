# This is a **reuseable** workflow that bundles the Desktop App for macOS.
# It doesn't get triggered on its own. It gets used in multiple workflows:
#  - release.yml
#  - canary.yml
#  - pr-comment-bundle-desktop.yml
on:
  workflow_call:
    inputs:
      version:
        description: 'Version to set for the build'
        required: false
        default: ""
        type: string
      signing:
        description: 'Whether to perform signing and notarization'
        required: false
        default: false
        type: boolean
      quick_test:
        description: 'Whether to perform the quick launch test'
        required: false
        default: true
        type: boolean
      ref:
        description: 'Git ref to checkout (branch, tag, or SHA). Defaults to main branch if not specified.'
        required: false
        type: string
        default: ''
    secrets:
      CERTIFICATE_OSX_APPLICATION:
        description: 'Certificate for macOS application signing'
        required: false
      CERTIFICATE_PASSWORD:
        description: 'Password for the macOS certificate'
        required: false
      APPLE_ID:
        description: 'Apple ID for notarization'
        required: false
      APPLE_ID_PASSWORD:
        description: 'Password for the Apple ID'
        required: false
      APPLE_TEAM_ID:
        description: 'Apple Team ID'
        required: false

name: Reusable workflow to bundle desktop app

env:
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0  # Disable incremental compilation to save space
  RUST_BACKTRACE: 1

jobs:
  bundle-desktop:
    runs-on: macos-latest
    name: Bundle Desktop App on macOS
    steps:
      # Debug information about the workflow and inputs
      - name: Debug workflow info
        env:
          WORKFLOW_NAME: ${{ github.workflow }}
          WORKFLOW_REF: ${{ github.ref }}
          EVENT_NAME: ${{ github.event_name }}
          REPOSITORY: ${{ github.repository }}
          INPUT_REF: ${{ inputs.ref }}
          INPUT_VERSION: ${{ inputs.version }}
          INPUT_SIGNING: ${{ inputs.signing }}
          INPUT_QUICK_TEST: ${{ inputs.quick_test }}
        run: |
          echo "=== Workflow Information ==="
          echo "Workflow: ${WORKFLOW_NAME}"
          echo "Ref: ${WORKFLOW_REF}"
          echo "Event: ${EVENT_NAME}"
          echo "Repo: ${REPOSITORY}"
          echo ""
          echo "=== Input Parameters ==="
          echo "Build ref: ${INPUT_REF:-<default branch>}"
          echo "Version: ${INPUT_VERSION:-not set}"
          echo "Signing: ${INPUT_SIGNING:-false}"
          echo "Quick test: ${INPUT_QUICK_TEST:-true}"

      # Check initial disk space
      - name: Check initial disk space
        run: df -h

      # Validate Signing Secrets if signing is enabled
      - name: Validate Signing Secrets
        if: ${{ inputs.signing }}
        env:
          HAS_CERT: ${{ secrets.CERTIFICATE_OSX_APPLICATION != '' }}
          HAS_CERT_PASS: ${{ secrets.CERTIFICATE_PASSWORD != '' }}
          HAS_APPLE_ID: ${{ secrets.APPLE_ID != '' }}
          HAS_APPLE_PASS: ${{ secrets.APPLE_ID_PASSWORD != '' }}
          HAS_TEAM_ID: ${{ secrets.APPLE_TEAM_ID != '' }}
        run: |
          missing=()
          [[ "${HAS_CERT}" != "true" ]] && missing+=("CERTIFICATE_OSX_APPLICATION")
          [[ "${HAS_CERT_PASS}" != "true" ]] && missing+=("CERTIFICATE_PASSWORD")
          [[ "${HAS_APPLE_ID}" != "true" ]] && missing+=("APPLE_ID")
          [[ "${HAS_APPLE_PASS}" != "true" ]] && missing+=("APPLE_ID_PASSWORD")
          [[ "${HAS_TEAM_ID}" != "true" ]] && missing+=("APPLE_TEAM_ID")
          
          if (( ${#missing[@]} > 0 )); then
            echo "Error: Missing required signing secrets:"
            printf '%s\n' "${missing[@]}"
            exit 1
          fi
          echo "All required signing secrets are present."

      # macOS disk cleanup
      - name: Free up disk space (macOS)
        run: |
          echo "=== Initial Disk Usage ==="
          df -h
          echo ""
          echo "=== Cleaning up disk space ==="
          
          # Clean npm cache
          npm cache clean --force 2>/dev/null || true
          # Clean Homebrew cache
          brew cleanup 2>/dev/null || true
          # Remove unnecessary large directories
          rm -rf ~/Library/Caches/* 2>/dev/null || true
          # Clean docker if present
          docker system prune -af 2>/dev/null || true
          # Remove old Xcode simulators
          xcrun simctl delete unavailable 2>/dev/null || true
          
          echo ""
          echo "=== Disk Usage After Cleanup ==="
          df -h

      # Checkout with specific ref if provided
      - name: Checkout Code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # pin@v4
        with:
          ref: ${{ inputs.ref || github.ref }}

      # Install and configure sccache with fallback options
      - name: Install sccache
        run: |
          SCCACHE_VERSION=v0.8.2
          curl -L "https://github.com/mozilla/sccache/releases/download/${SCCACHE_VERSION}/sccache-${SCCACHE_VERSION}-x86_64-apple-darwin.tar.gz" | tar xz
          sudo mv sccache-*/sccache /usr/local/bin/
          echo "RUSTC_WRAPPER=sccache" >> $GITHUB_ENV
          echo "SCCACHE_GHA_ENABLED=true" >> $GITHUB_ENV
          # Fallback to local cache if GHA cache fails
          echo "SCCACHE_GHA_CACHE_TO=gha" >> $GITHUB_ENV
          echo "SCCACHE_GHA_CACHE_FROM=gha" >> $GITHUB_ENV

      # Use updated sccache action with better error handling
      - name: Run sccache-cache
        uses: mozilla-actions/sccache-action@676c0e67b665684f17941acf5cc3af83bcf10228 # pin@v0.0.6
        continue-on-error: true  # Don't fail build if cache setup fails

      # Fallback: Set up local sccache if GHA cache fails
      - name: Setup fallback sccache
        if: failure()
        run: |
          echo "GitHub Actions cache failed, using local cache"
          mkdir -p ~/.cache/sccache
          echo "SCCACHE_DIR=~/.cache/sccache" >> $GITHUB_ENV
          echo "SCCACHE_GHA_ENABLED=false" >> $GITHUB_ENV

      # Optimized cargo caching for macOS
      - name: Cache Cargo and Target
        uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # pin@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-target-${{ hashFiles('**/Cargo.lock') }}-v4
          restore-keys: |
            ${{ runner.os }}-cargo-target-${{ hashFiles('**/Cargo.lock') }}-
            ${{ runner.os }}-cargo-target-

      # Clean cargo cache if it's too large
      - name: Limit cache sizes
        run: |
          # Check and limit cargo cache size
          CARGO_CACHE_SIZE=$(du -sm ~/.cargo 2>/dev/null | cut -f1 || echo "0")
          echo "Cargo cache size: ${CARGO_CACHE_SIZE}MB"
          
          if [ "$CARGO_CACHE_SIZE" -gt 3000 ]; then
            echo "Cargo cache too large (${CARGO_CACHE_SIZE}MB), cleaning..."
            rm -rf ~/.cargo/registry/cache
            rm -rf ~/.cargo/git/db
            echo "Cleaned cargo cache"
          fi
          
          # Check target directory size
          if [ -d "target" ]; then
            TARGET_SIZE=$(du -sm target 2>/dev/null | cut -f1 || echo "0")
            echo "Target directory size: ${TARGET_SIZE}MB"
            
            if [ "$TARGET_SIZE" -gt 8000 ]; then
              echo "Target directory too large (${TARGET_SIZE}MB), cleaning..."
              rm -rf target/release/incremental
              find target -name "*.rmeta" -delete 2>/dev/null || true
              echo "Cleaned target directory"
            fi
          fi

      # Install Go for building temporal-service
      - name: Set up Go
        uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # pin@v5
        with:
          go-version: '1.21'

      - name: Check disk space before build
        run: df -h

      # Build the project
      - name: Build goosed
        run: source ./bin/activate-hermit && cargo build --release -p goose-server

      - name: Clean intermediate artifacts after build
        run: |
          echo "Cleaning intermediate build artifacts..."
          # Remove .rmeta files (metadata only, not needed)
          find target -name "*.rmeta" -delete 2>/dev/null || true
          # Remove fingerprint files
          find target -name ".fingerprint" -type d -exec rm -rf {} + 2>/dev/null || true
          df -h

      # Build temporal-service
      - name: Build temporal-service
        run: |
          echo "Building temporal-service..."
          cd temporal-service
          go build -o temporal-service main.go
          chmod +x temporal-service
          echo "temporal-service built successfully"

      # Install and prepare temporal CLI
      - name: Install temporal CLI via hermit
        run: |
          echo "Installing temporal CLI via hermit..."
          ./bin/hermit install temporal-cli
          echo "temporal CLI installed successfully"

      # Post-build cleanup to free space
      - name: Post-build cleanup
        run: |
          echo "Performing post-build cleanup..."
          # Remove debug artifacts
          rm -rf target/debug 2>/dev/null || true
          # Keep only what's needed for the next steps
          rm -rf target/release/deps 2>/dev/null || true
          rm -rf target/release/build 2>/dev/null || true
          rm -rf target/release/incremental 2>/dev/null || true
          # Clean Go build cache
          go clean -cache 2>/dev/null || true
          df -h

      - name: Copy binaries into Electron folder
        run: |
          cp target/release/goosed ui/desktop/src/bin/goosed
          cp temporal-service/temporal-service ui/desktop/src/bin/temporal-service
          cp bin/temporal ui/desktop/src/bin/temporal

      - name: Add MacOS certs for signing and notarization
        if: ${{ inputs.signing }}
        run: ./scripts/add-macos-cert.sh
        working-directory: ui/desktop
        env:
          CERTIFICATE_OSX_APPLICATION: ${{ secrets.CERTIFICATE_OSX_APPLICATION }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}

      - name: Install dependencies
        run: source ../../bin/activate-hermit && npm ci
        working-directory: ui/desktop

      # Check disk space before bundling
      - name: Check disk space before bundling
        run: df -h

      - name: Make Unsigned App
        if: ${{ !inputs.signing }}
        run: source ../../bin/activate-hermit && npm run make
        working-directory: ui/desktop

      - name: Make Signed and Notarized App
        if: ${{ inputs.signing }}
        run: source ../../bin/activate-hermit && npm run make:signed
        working-directory: ui/desktop
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      - name: Show sccache stats
        run: sccache --show-stats

      - name: Final cleanup before artifact upload
        run: |
          echo "Performing final cleanup..."
          # Remove build artifacts that are no longer needed
          rm -rf target 2>/dev/null || true
          # Clean npm cache
          npm cache clean --force 2>/dev/null || true
          df -h

      - name: Upload Desktop artifact
        uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # pin@v4
        with:
          name: Goose-darwin-arm64
          path: ui/desktop/out/Goose-darwin-arm64/Goose.zip

      - name: Quick launch test (macOS)
        if: ${{ inputs.quick_test }}
        run: |
          # Ensure no quarantine attributes (if needed)
          xattr -cr "ui/desktop/out/Goose-darwin-arm64/Goose.app"
          echo "Opening Goose.app..."
          open -g "ui/desktop/out/Goose-darwin-arm64/Goose.app"

          # Give the app a few seconds to start and write logs
          sleep 5

          # Check if the app is running
          if pgrep -f "Goose.app" > /dev/null; then
            echo "✅ Goose.app launched successfully"
            # Kill the app after test
            pkill -f "Goose.app" || true
          else
            echo "❌ Goose.app failed to launch"
            # Check for crash logs
            echo "Checking for crash logs..."
            ls -la ~/Library/Logs/DiagnosticReports/ | grep -i goose | tail -5 || true
            exit 1
          fi
