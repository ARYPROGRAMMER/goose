name: "Bundle Desktop (Windows)"

on:
#  push:
#    branches: [ "main" ]
#  pull_request:
#    branches: [ "main" ]
  workflow_call:
    inputs:
      signing:
        description: 'Whether to sign the Windows executable'
        required: false
        type: boolean
        default: false
    secrets:
      WINDOWS_CERTIFICATE:
        required: false
      WINDOWS_CERTIFICATE_PASSWORD:
        required: false

jobs:
  build-desktop-windows:
    name: Build Desktop (Windows)
    runs-on: windows-latest
    strategy:
      matrix:
        target: [x86_64-pc-windows-msvc]  # Using MSVC for better Windows compatibility

    steps:
      # 1) Check out source
      - name: Checkout repository
        uses: actions/checkout@f43a0e5ff2bd294095638e18286ca9a3d1956744

      # 2) Set up Rust with specific target
      - name: Set up Rust
        uses: dtolnay/rust-toolchain@38b70195107dddab2c7bbd522bcf763bac00963b
        with:
          toolchain: stable
          profile: minimal
          override: true
          target: x86_64-pc-windows-msvc

      # 3) Set up Node.js
      - name: Set up Node.js
        uses: actions/setup-node@1a4442cacd436585916779262731d5b162bc6ec7 # pin@v3
        with:
          node-version: 16

      # 4) Install protobuf and set environment
      - name: Install protobuf
        id: install-protobuf
        run: |
          # Get latest protoc release info from GitHub API
          Write-Host "Fetching latest protoc release information..."
          $latestRelease = (Invoke-RestMethod -Uri "https://api.github.com/repos/protocolbuffers/protobuf/releases/latest")
          $windowsAsset = $latestRelease.assets | Where-Object { $_.name -like "*win64.zip" }
          $PROTOC_VERSION = $latestRelease.tag_name -replace 'v', ''
          
          Write-Host "Latest protoc version: $PROTOC_VERSION"
          Write-Host "Downloading: $($windowsAsset.name)"
          
          $PROTOC_DIR = "C:\protoc"
          
          Write-Host "Creating protoc directory..."
          New-Item -ItemType Directory -Force -Path $PROTOC_DIR
          
          Write-Host "Downloading protoc..."
          Invoke-WebRequest -Uri $windowsAsset.browser_download_url -OutFile "$PROTOC_DIR\protoc.zip"
          
          Write-Host "Extracting protoc..."
          Expand-Archive -Path "$PROTOC_DIR\protoc.zip" -DestinationPath $PROTOC_DIR -Force
          
          # Set environment variables for the current process and future steps
          $protocPath = "$PROTOC_DIR\bin\protoc.exe"
          
          # Set for current process
          $env:PROTOC = $protocPath
          $env:Path = "$PROTOC_DIR\bin;" + $env:Path
          
          # Set for future steps
          echo "PROTOC=$protocPath" >> $env:GITHUB_ENV
          echo "$PROTOC_DIR\bin" >> $env:GITHUB_PATH
          
          # Create a .cargo/config.toml to set environment variables for cargo
          $cargoConfig = @"
          [env]
          PROTOC = "$protocPath"
          "@
          
          New-Item -ItemType Directory -Force -Path ".cargo"
          $cargoConfig | Out-File -FilePath ".cargo/config.toml" -Encoding utf8
          
          Write-Host "Created .cargo/config.toml:"
          Get-Content ".cargo/config.toml"
          
          # Verify installation
          Write-Host "Verifying protoc installation..."
          Write-Host "PROTOC env var: $env:PROTOC"
          Write-Host "protoc location:"
          Get-ChildItem -Path "$PROTOC_DIR\bin\protoc.exe"
          
          Write-Host "protoc version:"
          & $protocPath --version
          
          # Test protoc functionality
          Write-Host "Testing protoc functionality..."
          $testProto = @"
          syntax = "proto3";
          package test;
          message Test {
            string test_field = 1;
          }
          "@
          
          $testProto | Out-File -FilePath "$PROTOC_DIR\test.proto"
          & $protocPath --proto_path="$PROTOC_DIR" "$PROTOC_DIR\test.proto"
          
          # Export the protoc path for other steps
          echo "::set-output name=protoc_path::$protocPath"
        shell: powershell

      # 5) Install MinGW
      - name: Install MinGW
        run: |
          choco install mingw --version=8.1.0 --yes
          refreshenv

      # 6) Cache dependencies
      - name: Calculate source hash
        id: source_hash
        shell: bash
        run: |
          SOURCE_HASH=$(find . -type f -name "*.rs" -exec sha256sum {} \; | sort | sha256sum | cut -d ' ' -f1)
          echo "hash=${SOURCE_HASH}" >> $GITHUB_OUTPUT

      - name: Cache Cargo
        id: cargo-cache
        uses: actions/cache@2f8e54208210a422b2efd51efaa6bd6d7ca8920f # pin@v3
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            target
            node_modules
            ui/desktop/node_modules
          key: ${{ runner.os }}-cargo-v2-msvc-${{ hashFiles('**/Cargo.lock') }}-${{ steps.source_hash.outputs.hash }}
          restore-keys: |
            ${{ runner.os }}-cargo-v2-msvc-${{ hashFiles('**/Cargo.lock') }}-
            ${{ runner.os }}-cargo-v2-msvc-

      # 7) Build rust with MSVC toolchain
      - name: Build Release Binary
        run: |
          Write-Host "Environment Check:"
          Write-Host "PROTOC: $env:PROTOC"
          Write-Host "PATH: $env:Path"
          
          Write-Host "Testing protoc directly:"
          & $env:PROTOC --version
          
          Write-Host ".cargo/config.toml contents:"
          Get-Content ".cargo/config.toml"
          
          Write-Host "Building with Cargo..."
          $env:RUST_LOG = "debug"
          
          # Set PROTOC explicitly in the environment again
          $env:PROTOC = "${{ steps.install-protobuf.outputs.protoc_path }}"
          
          cargo clean
          cargo build --release --target x86_64-pc-windows-msvc -j 4 -vv
        env:
          CARGO_BUILD_JOBS: "4"
          RUSTFLAGS: "-C opt-level=3"
          CARGO_INCREMENTAL: "0"
          RUST_BACKTRACE: "full"
          RUST_LOG: "debug"
          PROTOC: "${{ steps.install-protobuf.outputs.protoc_path }}"

      # 8) Check that the compiled goosed.exe exists and copy to ui/desktop/src/bin
      - name: Prepare Windows binary and DLLs
        run: |
          $binaryPath = ".\target\${{ matrix.target }}\release\goosed.exe"
          if (!(Test-Path $binaryPath)) {
            Write-Error "Windows binary not found at $binaryPath"; exit 1;
          }
          
          Write-Host "Copying Windows binary and DLLs to ui/desktop/src/bin..."
          if (!(Test-Path ui\desktop\src\bin)) {
            New-Item -ItemType Directory -Path ui\desktop\src\bin | Out-Null
          }
          Copy-Item $binaryPath ui\desktop\src\bin\
          
          # Copy MinGW DLLs - try both possible locations
          $mingwPaths = @(
            "C:\ProgramData\chocolatey\lib\mingw\tools\install\mingw64\bin",
            "C:\tools\mingw64\bin"
          )
          
          foreach ($path in $mingwPaths) {
            if (Test-Path "$path\libstdc++-6.dll") {
              Write-Host "Found MinGW DLLs in $path"
              Copy-Item "$path\libstdc++-6.dll" ui\desktop\src\bin\
              Copy-Item "$path\libgcc_s_seh-1.dll" ui\desktop\src\bin\
              Copy-Item "$path\libwinpthread-1.dll" ui\desktop\src\bin\
              break
            }
          }
          
          # Copy any other DLLs from the release directory
          Get-ChildItem ".\target\${{ matrix.target }}\release\*.dll" -ErrorAction SilentlyContinue | ForEach-Object {
            Copy-Item $_.FullName ui\desktop\src\bin\
          }

      # 9) Install & build UI desktop
      - name: Build desktop UI with npm
        run: |
          cd ui\desktop
          npm install
          npm run bundle:windows

      # 10) Copy exe/dll to final out/Goose-win32-x64/resources/bin
      - name: Copy exe/dll to out folder
        run: |
          cd ui\desktop
          if (!(Test-Path .\out\Goose-win32-x64\resources\bin)) {
            New-Item -ItemType Directory -Path .\out\Goose-win32-x64\resources\bin | Out-Null
          }
          Copy-Item .\src\bin\goosed.exe .\out\Goose-win32-x64\resources\bin\
          Get-ChildItem .\src\bin\*.dll -ErrorAction SilentlyContinue | ForEach-Object {
            Copy-Item $_.FullName .\out\Goose-win32-x64\resources\bin\
          }

      # 11) Code signing (if enabled)
      - name: Sign Windows executable
        if: inputs.signing && inputs.signing == true
        env:
          WINDOWS_CERTIFICATE: ${{ secrets.WINDOWS_CERTIFICATE }}
          WINDOWS_CERTIFICATE_PASSWORD: ${{ secrets.WINDOWS_CERTIFICATE_PASSWORD }}
        run: |
          # Create a temporary certificate file
          $certBytes = [Convert]::FromBase64String($env:WINDOWS_CERTIFICATE)
          $certPath = Join-Path -Path $env:RUNNER_TEMP -ChildPath "certificate.pfx"
          [IO.File]::WriteAllBytes($certPath, $certBytes)
          
          # Sign the main executable
          $signtool = "C:\Program Files (x86)\Windows Kits\10\bin\10.0.17763.0\x64\signtool.exe"
          & $signtool sign /f $certPath /p $env:WINDOWS_CERTIFICATE_PASSWORD /tr http://timestamp.digicert.com /td sha256 /fd sha256 "ui\desktop\out\Goose-win32-x64\Goose.exe"
          
          # Clean up the certificate
          Remove-Item -Path $certPath

      # 12) Upload the final Windows build
      - name: Upload Windows build artifacts
        uses: actions/upload-artifact@4cec3d8aa04e39d1a68397de0c4cd6fb9dce8ec1 # pin@v4
        with:
          name: desktop-windows-dist
          path: ui/desktop/out/Goose-win32-x64/